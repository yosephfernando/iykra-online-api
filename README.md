## SAMPLE .env ##
```
MONGODB_URI=mongodb://{username}:{password}@{mongohost}:{mongoport}/{dbname}?authSource=admin
RUST_LOG=actix_web=debug
```
## FOLDER STRUCTURE ##
- **`/src/`**: Contains all the Rust source code files for your project.
    - **`main.rs`**: This is the main entry point of the program.
    - **`config.rs`**: This is config modules declaration
    - **`config/`**: This is the contain app interfaces & database configuration.
        - **`app_config.rs`**
        - **`db_conn.rs`**
    - **`about_modules.rs`**: This is about modules declaration
    - **`about_modules/`**: This is the module directory that contains http handlers, data structure, and bussiness logic.
        - **`controllers/`**
        - **`models/`**
        - **`services/`**
    - **`corporate_modules.rs`**: This is corporate modules declaration
    - **`corporate_modules/`**: This is the module directory that contains http handlers, data structure, and bussiness logic.
        - **`controllers/`**
        - **`models/`**
        - **`services/`**
- **`/target/`**: This folder is generated by Cargo when you build your project. It contains compiled artifacts, such as `debug` and `release` builds.
- **`Cargo.toml`**: The Cargo configuration file for the project. It contains the metadata, dependencies, and other settings for the Rust project.
- **`Cargo.lock`**: This file locks the versions of dependencies used by the project to ensure consistent builds.

## ADDING NEW MODULES ##
When adding a new module, follow these steps to ensure it integrates well with the existing project structure and functionality.
1. **Create a New Module Directory**

    In the src/ directory, create a new folder for your module. This folder will contain all relevant files for your module, including controllers, models, and services.

    For example, if you're adding a module for **"product"** functionality, you would create the following structure:
    - **`product_modules/`**
        - **`controllers/`**
        - **`models/`**
        - **`services/`**
2. **Define the Module Files**

    Inside your module directory, create the necessary files:
    - **controllers/**: Contains the HTTP request handlers (e.g., for GET, POST, PUT, DELETE routes).
    - **models/**: Contains data structures that represent the entities or models within this module.
    - **services/**: Contains the business logic and operations for the module.

    For example, within src/product_modules/ you might have:
    - **controllers/product.rs**
    - **models/product.rs**
    - **services/product.rs**
3. **Declare the Module in `product_modules.rs`**

    In the `src/product_modules.rs` file, declare the newly created module. This ensures the module can be accessed from other parts of the application.

    ```
    pub mod controllers;
    pub mod models;
    pub mod services;
    ```
4. **Add the Module's Routes in `app_config.rs`**

    Once the module is declared, you need to update the app_config.rs file to include the routes for your new module. This file is responsible for configuring all HTTP routes in your application.

    In the case of the **"product"** module, add a similar block of code for defining routes:

    ```
    use crate::product_modules::controllers::{product};

    pub fn configure_app(cfg: &mut web::ServiceConfig) {
        cfg.service(
            web::resource("/product")
                .route(web::get().to(product::index))
                .route(web::put().to(product::update))
                .route(web::post().to(product::create))
                .route(web::delete().to(product::delete))
                .route(web::head().to(HttpResponse::MethodNotAllowed)),
        );
    }
    ```

    Make sure that the paths for `product::index`, `product::update`, etc., match the functions defined in the controllers of your new module.
5. **Implement Controller Logic**

    In the `src/product_modules/controllers/product.rs` file, implement the HTTP request handlers for each route (GET, POST, PUT, DELETE). For example:

    ```
    use actix_web::{HttpResponse, Responder};

    pub async fn index() -> impl Responder {
        HttpResponse::Ok().json("Product Index")
    }

    pub async fn create() -> impl Responder {
        HttpResponse::Created().json("Product Created")
    }

    pub async fn update() -> impl Responder {
        HttpResponse::Ok().json("Product Updated")
    }

    pub async fn delete() -> impl Responder {
        HttpResponse::Ok().json("Product Deleted")
    }
    ```
6. **Define the Data Models**

    In the `src/product_modules/models/product.rs` file, define the necessary data structures (models) for your module. These might represent entities like Product, Category, etc.

    ```
    use serde::{Serialize, Deserialize};

    #[derive(Serialize, Deserialize)]
    pub struct Product {
        pub id: i32,
        pub name: String,
        pub price: f64,
    }
    ```
7. **Implement Business Logic in Services**

    In the `src/product_modules/services/product.rs` file, define the business logic or service functions that interact with your models or handle the core functionality of your module.

    ```
    use crate::product_modules::models::Product;

    pub fn get_product_by_id(id: i32) -> Option<Product> {
        // Business logic to retrieve product by ID
        Some(Product {
            id,
            name: String::from("Sample Product"),
            price: 99.99,
        })
    }
    ```
8. **Test and Validate**

    After implementing the module, test it to ensure the routes work as expected, the data models are correct, and the business logic in the services is functional.

    Hereâ€™s a curl command to test and validate your API at `127.0.0.1:8080/api/product`

    ```curl -X GET "http://127.0.0.1:8080/api/product" -H "Accept: application/json"```

    ```curl -X POST "http://127.0.0.1:8080/api/product" -H "Content-Type: application/json" -d '{"name": "Product A", "price": 100.0}'```

    ```curl -X PUT "http://127.0.0.1:8080/api/product" -H "Content-Type: application/json" -d '{"_id": "uuid", "name": "Updated Product", "price": 150.0}'```

    ```curl -X DELETE "http://127.0.0.1:8080/api/product" -H "Content-Type: application/json" -d '{"_id": "uuid"}'```
